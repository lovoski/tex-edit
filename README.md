# tex-edit 项目文档

## 项目结构：

- `server` ：服务器所在的文件夹，这个服务器完全由C语言编写，为了连接mysql数据库调用mysqlclient的头文件和动态链接库（动态链接库在`server/lib`文件夹下）。同时含有我自己对mysql的cAPI的简单封装头文件和实现文件，对于字符串处理的个人实现，包含一些测试用的文件和用于编译服务器的Makefile文件。

- `3rdparty` ：第三方库的头文件和我编译的相应库文件，编译出这些库文件花了我很长的时间尝试和学习工具的使用，包括CMake和编译链的下载编译搭建，让我对于各个应用的组成和系统调用的库的位置有了一些了解

- `src || ui || include` ：这些都是qt项目所在的位置，源文件，头文件和ui文件

## 实现的功能：

- 对于离线状态：
  
  - 可以打开本地的文件编辑，保存

- 在连接到服务器以后：
  
  - 可以选择打开服务器数据库存储的文件，将编辑的文件保存到数据库
  
  - 编译当前编辑的tex文件（但是对于格式不规范的文件无法生成pdf文件），编译完后将pdf文件从服务端传回客户端利用命令行调用系统下的pdf阅览器显示pdf文件
  
  - 和其他的客户共同编辑当前的文件，实时显示（但是不能两个人同时编辑一行内容）

- 编译了`qscitinlla`和`poppler`：
  
  - 调用`qscitinlla`完成了前端的编辑器界面，但是由于时间原因没能调用`poppler`完成显示pdf的控件，采用QProcess调用系统中的pdf显示软件显示pdf
  
  - 编辑器界面调用`qscitinlla`的接口添加了行号和当前行的高亮，但是由于语法高亮和代码补全默认接口没有达到我的预期效果，我也没有更多的时间花在界面上，直接去掉了语法高亮和代码补全的功能

## 一些亮点：

- `非阻塞socket和的字符串处理的优化`：在这个学期之前的项目中，由于追求容易编写一直用阻塞socket实现强制的同步，但是我了解到这样是很低效的做法，没有充分利用cpu的能力，采用调用之后立即返回的非阻塞socket可以减少因为阻塞强制占用的时间片，提高服务端的性能，而且为了实现多人编辑，要让每个客户端的消息同步但是保持每次发送的数据量尽可能小，这也意味着不能把当前的所有文本暴力地全部发送给服务器，基于这两个想法我做了以下的优化：
  
  - 每一次的发送字节数定长，选取前四个字节作为标识符，包含当前信息是对服务端做出什么请求，可能是通知服务端将一个客户的操作发送给其他客户实现多人编辑的同步，可能是要求编译当前的tex文件，可能是要求打开位于数据库中的文件，可能是要求对文件的保存。对于大型的文件需要分多次发送，也通过标识符说明当前字节段是否为大文件的末尾字节段，最后依次将消息非阻塞地发送出去
  
  - 多人编辑时每人发送的是当前的操作而不是当前的全部文本，我将当前的文本通过行号分段，区分修改前后行号相等，不相等的三种情况，在文本段首尾设置指针，向中间遍历行段，指针指向的行不相等，记录两个指针最终的位置，有意义的情况一共有7种，对于每一种特殊处理，可以得到一些规律（此处省略），可以很大程度减小需要发送的数据量

- `通过多线程给每个客户端分别处理信息`：虽然采用非阻塞socket可以单线程完成任务，但是多线程可以提高处理的效率，也让程序更容易编写。每当一个客户端连接到服务端，分配出一个线程给客户端专门处理，通过统一编号管理每一个客户端使用的线程，当客户断开连接的时候，退出线程前清空和客户下标相关的所有信息，准备下一次连接

## 对于进一步优化的想法：

- 虽然当前我对传输数据量已经尽量减少，但是还有很多提升空间，可以通过线程池进一步提高对于线程的管理效率（当前我找到一个线程池的模板，但是实现太过简单，没有很大意义），对于大文件的传输也可以结合udp传输而不是一直使用tcp传输，也可以添加缓冲区来减少对于文件读取写入的io次数提高性能，而且我现在对于同步异步传输了解不够深入

- 对于字符串处理也可以进一步针对优化，现在我有大量的字符串分段操作，通过更精细的分段，选取高效的数据结构存储每一片段，提高遍历速度，当前也好有很多的字符串比较，也许还可以使用hash的方法提高比较时的速度

- 当前对于各个客户端对服务端的请求没有任何处理，没有加上线程锁，在极端情况下可能会很不安全，而且对于mysql的频繁写入写出也会影响性能，可以加上缓冲区存储常用的数据
